"github.com/kelseyhightower/envconfig"

godotenv
gotenv

Чтобы читать файл .env
Способ 1: Загрузить .env через библиотеку godotenv
go get github.com/joho/godotenv
Фрагмент коды:
type Config struct {
    Port  int  `envconfig:"PORT"`
    Debug bool `envconfig:"DEBUG"`
}

func main() {
    // Загружаем .env → в переменные окружения
    err := godotenv.Load()
    if err != nil {
        log.Println("⚠️ .env файл не найден")
    }

    // Читаем окружение через envconfig
    var cfg Config
    envconfig.Process("", &cfg)

    log.Println(cfg.Port, cfg.Debug)
}


migrate -path ./store/pg/migrations -database 'postgres://postgres:postgres@localhost:5435/erp2s?sslmode=disable' up
go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest


фрагмент:
func (u *UserRepository) Save(userToSave model.UserDB) (*model.UserDB, error) {
	query := `
        INSERT INTO users (first_name, email, login, password, user_role)
        VALUES (:first_name, :email, :login, :password, :user_role)
        RETURNING id`

	err := u.db.QueryRow(query,
		userToSave.FirstName,
		userToSave.Email,
		userToSave.Login,
		userToSave.Password,
		userToSave.UserRole,
	).Scan(&userToSave.Id)
	if err != nil {
		return nil, err
	}

	return &userToSave, nil
}


func (u *UserRepository) Save(userToSave model.UserDB) (*model.UserDB, error) {
    query := `
        INSERT INTO users (first_name, email, login, password, user_role)
        VALUES (:first_name, :email, :login, :password, :user_role)
        RETURNING id`

    rows, err := u.db.NamedQuery(query, userToSave)
    if err != nil {
        return nil, fmt.Errorf("failed to insert user: %w", err)
    }
    defer rows.Close()

    if !rows.Next() {
        if err := rows.Err(); err != nil {
            return nil, fmt.Errorf("rows iteration error: %w", err)
        }
        return nil, fmt.Errorf("no Id returned after insert")
    }

    if err := rows.Scan(&userToSave.Id); err != nil {
        return nil, fmt.Errorf("failed to scan user Id: %w", err)
    }

    return &userToSave, nil
}

rows, err := u.db.NamedQuery(query, userToSave)
if err != nil {
    // PostgreSQL unique constraint violation
    if pqErr, ok := err.(*pq.Error); ok {
        if pqErr.Code == "23505" { // unique_violation
            return nil, fmt.Errorf("user with this email or login already exists: %w", err)
        }
    }
    return nil, fmt.Errorf("failed to insert user: %w", err)
}

////
sync.OnceFunc(func() {
		if err := RunPgMigrations(db); err != nil {
			log.Fatalf("failed run migration %s", err.Error())
		}
	})

func handleValidationErrors(err error) *AppError {
	validationErrors, ok := err.(validator.ValidationErrors)
	if !ok {
		return ErrValidation
	}

	details := make(map[string]string)
	for _, e := range validationErrors {
		field := e.Field()
		switch e.Tag() {
		case "required":
			details[field] = fmt.Sprintf("Поле %s обязательно", field)
		case "email":
			details[field] = "Некорректный формат email"
		case "min":
			details[field] = fmt.Sprintf("Минимальная длина: %s", e.Param())
		case "max":
			details[field] = fmt.Sprintf("Максимальная длина: %s", e.Param())
		case "gte":
			details[field] = fmt.Sprintf("Значение должно быть >= %s", e.Param())
		case "lte":
			details[field] = fmt.Sprintf("Значение должно быть <= %s", e.Param())
		default:
			details[field] = fmt.Sprintf("Ошибка валидации: %s", e.Tag())
		}
	}