"github.com/kelseyhightower/envconfig"

godotenv
gotenv

Чтобы читать файл .env
Способ 1: Загрузить .env через библиотеку godotenv
go get github.com/joho/godotenv
Фрагмент коды:
type Config struct {
    Port  int  `envconfig:"PORT"`
    Debug bool `envconfig:"DEBUG"`
}

func main() {
    // Загружаем .env → в переменные окружения
    err := godotenv.Load()
    if err != nil {
        log.Println("⚠️ .env файл не найден")
    }

    // Читаем окружение через envconfig
    var cfg Config
    envconfig.Process("", &cfg)

    log.Println(cfg.Port, cfg.Debug)
}


migrate -path ./store/pg/migrations -database 'postgres://postgres:postgres@localhost:5435/erp2s?sslmode=disable' up
go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest


фрагмент:
func (u *UserRepository) Save(userToSave model.UserDB) (*model.UserDB, error) {
	query := `
        INSERT INTO users (first_name, email, login, password, user_role)
        VALUES (:first_name, :email, :login, :password, :user_role)
        RETURNING id`

	err := u.db.QueryRow(query,
		userToSave.FirstName,
		userToSave.Email,
		userToSave.Login,
		userToSave.Password,
		userToSave.UserRole,
	).Scan(&userToSave.Id)
	if err != nil {
		return nil, err
	}

	return &userToSave, nil
}


func (u *UserRepository) Save(userToSave model.UserDB) (*model.UserDB, error) {
    query := `
        INSERT INTO users (first_name, email, login, password, user_role)
        VALUES (:first_name, :email, :login, :password, :user_role)
        RETURNING id`

    rows, err := u.db.NamedQuery(query, userToSave)
    if err != nil {
        return nil, fmt.Errorf("failed to insert user: %w", err)
    }
    defer rows.Close()

    if !rows.Next() {
        if err := rows.Err(); err != nil {
            return nil, fmt.Errorf("rows iteration error: %w", err)
        }
        return nil, fmt.Errorf("no Id returned after insert")
    }

    if err := rows.Scan(&userToSave.Id); err != nil {
        return nil, fmt.Errorf("failed to scan user Id: %w", err)
    }

    return &userToSave, nil
}

rows, err := u.db.NamedQuery(query, userToSave)
if err != nil {
    // PostgreSQL unique constraint violation
    if pqErr, ok := err.(*pq.Error); ok {
        if pqErr.Code == "23505" { // unique_violation
            return nil, fmt.Errorf("user with this email or login already exists: %w", err)
        }
    }
    return nil, fmt.Errorf("failed to insert user: %w", err)
}

////
sync.OnceFunc(func() {
		if err := RunPgMigrations(db); err != nil {
			log.Fatalf("failed run migration %s", err.Error())
		}
	})

func handleValidationErrors(err error) *AppError {
	validationErrors, ok := err.(validator.ValidationErrors)
	if !ok {
		return ErrValidation
	}

	details := make(map[string]string)
	for _, e := range validationErrors {
		field := e.Field()
		switch e.Tag() {
		case "required":
			details[field] = fmt.Sprintf("Поле %s обязательно", field)
		case "email":
			details[field] = "Некорректный формат email"
		case "min":
			details[field] = fmt.Sprintf("Минимальная длина: %s", e.Param())
		case "max":
			details[field] = fmt.Sprintf("Максимальная длина: %s", e.Param())
		case "gte":
			details[field] = fmt.Sprintf("Значение должно быть >= %s", e.Param())
		case "lte":
			details[field] = fmt.Sprintf("Значение должно быть <= %s", e.Param())
		default:
			details[field] = fmt.Sprintf("Ошибка валидации: %s", e.Tag())
		}
	}


***
func ValidationError(err error) Response {
    details, parseErr := handleValidateErr(err)
    if parseErr != nil {
        return InternalServerError()
    }
    return Response{
        Code:    http.StatusUnprocessableEntity,
        Message: "Validation failed",
        Body:    details,
    }
}

func OK(body any) Response {
    return Response{
        Code: http.StatusOK,
        Body: body,
    }
}
// Render implements chi's render.Renderer interface
func (r Response) Render(w http.ResponseWriter, req *http.Request) error {
    render.Status(req, r.Code)
    return nil
}

// Send отправляет Response через chi render
func (r Response) Send(w http.ResponseWriter, req *http.Request) {
    render.Render(w, req, r)
}
// Вариант 1: через .Send()
func GetUser(w http.ResponseWriter, r *http.Request) {
    user, err := userService.Get(id)
    if err != nil {
        response.NotFound("User not found").Send(w, r)
        return
    }
    response.OK(user).Send(w, r)
}

// Вариант 2: напрямую через render
func CreateUser(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest
    if err := render.Bind(r, &req); err != nil {
        render.Render(w, r, response.ValidationError(err))
        return
    }

    user, err := userService.Create(req)
    if err != nil {
        render.Render(w, r, response.InternalServerError())
        return
    }

    render.Render(w, r, response.Created(user))
}

**
render.Bind — это функция из chi/render,
которая десериализует HTTP запрос в Go структуру и вызывает её метод валидации.
// 1. Определяешь структуру запроса
type CreateUserRequest struct {
    Email    string `json:"email" validate:"required,email"`
    Password string `json:"password" validate:"required,min=8"`
    Name     string `json:"name" validate:"required"`
}

// 2. Реализуешь интерфейс render.Binder
func (req *CreateUserRequest) Bind(r *http.Request) error {
    // Здесь можно добавить кастомную валидацию
    if req.Email == "" {
        return errors.New("email is required")
    }

    // Или использовать validator
    validate := validator.New()
    if err := validate.Struct(req); err != nil {
        return err
    }

    return nil
}

// 3. В handler используешь render.Bind
func CreateUser(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest

    // render.Bind делает 2 вещи:
    // - декодирует JSON из body в &req
    // - вызывает req.Bind(r) для валидации
    if err := render.Bind(r, &req); err != nil {
        response.ValidationError(err).Send(w, r)
        return
    }

    // req уже провалидирован и готов к использованию
    user := createUser(req)
    response.Created(user).Send(w, r)
}

Улучшенная обработка в твоём пакете:

package response

import (
    "encoding/json"
    "errors"
    "fmt"
    "net/http"

    "github.com/go-chi/render"
    "github.com/go-playground/validator/v10"
)

// BindAndValidate обёртка над render.Bind с умной обработкой ошибок
func BindAndValidate(r *http.Request, v render.Binder) Response {
    if err := render.Bind(r, v); err != nil {
        // Проверяем, это ошибка валидации или декодирования
        var validationErr validator.ValidationErrors
        if errors.As(err, &validationErr) {
            return ValidationError(err)
        }

        // Ошибка декодирования JSON
        var jsonErr *json.UnmarshalTypeError
        if errors.As(err, &jsonErr) {
            return BadRequest(fmt.Sprintf("Invalid type for field '%s'", jsonErr.Field))
        }

        // Другие ошибки
        return BadRequest("Invalid request format")
    }

    return Response{} // пустой Response = успех
}

func ValidationError(err error) Response {
    details, parseErr := handleValidateErr(err)
    if parseErr != nil {
        return InternalServerError()
    }
    return Response{
        Code:    http.StatusUnprocessableEntity,
        Message: "Validation failed",
        Body:    details,
    }
}
Использование в handler:
func CreateUser(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest

    // Умная обработка всех типов ошибок
    if resp := response.BindAndValidate(r, &req); resp.Code != 0 {
        resp.Send(w, r)
        return
    }

    // req декодирован и провалидирован ✅
    user := createUser(req)
    response.Created(user).Send(w, r)
}
```

## Итог:
```
HTTP Request
    ↓
render.Bind(r, &req)
    ↓
1. Decode(r, &req)           ← декодирует JSON в структуру
    ↓
2. req.Bind(r)               ← вызывает твой метод валидации
    ↓
return error (или nil)


delivery
func DeliveryFromDTO(dto DeliveryToSave) (*Delivery, error) {
	items := make([]DeliveryItem, 0, len(dto.Items))

	for _, i := range dto.Items {
		item, err := NewDeliveryItem(i.ProductID, i.ItemPrice, i.Quantity)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}

	return NewDelivery(items, dto.RecipientGoods, dto.Address)
}

func (d *Delivery) ChangeStatus(status DeliveryStatus) error {
	if err := status.IsValid(); err != nil {
		return err
	}

	// пример бизнес-правила
	if d.status == StatusCancelled {
		return ErrDeliveryAlreadyCancelled
	}

	d.status = status
	return nil
}

func NewDelivery(
	items []DeliveryItem,
	recipientGoods string,
	address string,
) (*Delivery, error) {

	if len(items) == 0 {
		return nil, ErrEmptyDeliveryItems
	}
	if recipientGoods == "" {
		return nil, ErrEmptyRecipient
	}
	if address == "" {
		return nil, ErrEmptyAddress
	}

	d := &Delivery{
		items:          items,
		recipientGoods: recipientGoods,
		address:        address,
		status:         StatusCreated,
		createdAt:      time.Now(),
	}

	d.recalculateTotal()

	return d, nil
}

package model

type DeliveryItem struct {
	ProductID int64
	ItemPrice int64
	Quantity  int64
}

func NewDeliveryItem(
	productID int64,
	itemPrice int64,
	quantity int64,
) (DeliveryItem, error) {

	if productID <= 0 {
		return DeliveryItem{}, ErrInvalidProduct
	}
	if itemPrice <= 0 {
		return DeliveryItem{}, ErrInvalidPrice
	}
	if quantity <= 0 {
		return DeliveryItem{}, ErrInvalidQuantity
	}

	return DeliveryItem{
		ProductID: productID,
		ItemPrice: itemPrice,
		Quantity:  quantity,
	}, nil
}

func (i DeliveryItem) Total() int64 {
	return i.ItemPrice * i.Quantity
}

package model

import "erp-2c/lib/types"

type DeliveryStatus string

const (
	StatusCreated   DeliveryStatus = "CREATED"
	StatusAccepted  DeliveryStatus = "ACCEPTED"
	StatusShipped   DeliveryStatus = "SHIPPED"
	StatusDelivered DeliveryStatus = "DELIVERED"
	StatusCancelled DeliveryStatus = "CANCELLED"
)

func NewDeliveryStatus(s string) (DeliveryStatus, error) {
	status := DeliveryStatus(s)
	if err := status.IsValid(); err != nil {
		return "", err
	}
	return status, nil
}

func (s DeliveryStatus) IsValid() error {
	switch s {
	case StatusCreated, StatusAccepted, StatusShipped, StatusDelivered, StatusCancelled:
		return nil
	default:
		return types.NewAppErr(string(s), types.ErrUnknownStatus)
	}
}

///update
package model

import "time"

// ====================
// Доменные модели
// ====================
type DeliveryItem struct {
	Product   ProductDomain
	ItemPrice int64
	Quantity  int64
}

func (i *DeliveryItem) TotalAmount() int64 {
	return i.ItemPrice * i.Quantity
}

type DeliveryItemDomain struct {
	Id             int64
	DeliveryItems  []DeliveryItem
	RecipientGoods string
	Address        string
	StatusDelivery DeliveryStatus
	CreatedAt      time.Time
	TotalAmount    int64
}

// ====================
// Методы для работы с товарами
// ====================

// Добавление товара
func (d *DeliveryItemDomain) AddItem(item DeliveryItem) {
	d.DeliveryItems = append(d.DeliveryItems, item)
	d.updateTotal() // автоматически синхронизируем TotalAmount
}

// Удаление товара по индексу
func (d *DeliveryItemDomain) RemoveItem(index int) {
	if index < 0 || index >= len(d.DeliveryItems) {
		return
	}
	d.DeliveryItems = append(d.DeliveryItems[:index], d.DeliveryItems[index+1:]...)
	d.updateTotal() // автоматически синхронизируем TotalAmount
}

// Обновление количества/цены товара по индексу
func (d *DeliveryItemDomain) UpdateItem(index int, item DeliveryItem) {
	if index < 0 || index >= len(d.DeliveryItems) {
		return
	}
	d.DeliveryItems[index] = item
	d.updateTotal() // автоматически синхронизируем TotalAmount
}

// ====================
// Внутренний метод для синхронизации суммы
// ====================
func (d *DeliveryItemDomain) updateTotal() {
	var total int64
	for _, item := range d.DeliveryItems {
		total += item.TotalAmount()
	}
	d.TotalAmount = total
}

// ❌ Ошибка 1: Двойной Rollback
defer tx.Rollback()
if err := tx.Commit(); err != nil {
    return err  // Rollback вызовется снова!
}

// ❌ Ошибка 2: Игнорируем ошибку Rollback
defer tx.Rollback()  // Ошибка может быть, но мы ее игнорируем

// ❌ Ошибка 3: Rollback после успешного Commit
if err := tx.Commit(); err != nil {
    return err
}
defer tx.Rollback()  // Слишком поздно!


committed := false

defer func() {
    if committed {
        return
    }

    if err := tx.Rollback(); err != nil && !errors.Is(err, sql.ErrTxDone) {
        sLogger.Error("rollback failed", sl.Err(err))
    } else {
        sLogger.Debug("transaction rolled back")
    }
}()

if err := tx.Commit(); err != nil {
    return err
}
committed = true


_, err := tx.CopyFrom(
	ctx,
	pgx.Identifier{"delivery_items"},
	[]string{"delivery_id", "product_id", "quantity", "item_price"},
	pgx.CopyFromRows(
		deliveryItemsToCopyRows(delivery.ID, delivery.DeliveryItemsDB),
	),
)
if err != nil {
	return nil, types.NewAppErr(
		"failed to copy delivery items",
		errors.Join(err, types.ErrInspectedSQL),
	)
}


**********
BatchSize
UPDATE delivery d
SET status = u.status
FROM unnest($1::int[], $2::text[]) AS u(id, status)
WHERE d.id = u.id;

ids := make([]int, 0, len(deliveries))
statuses := make([]string, 0, len(deliveries))

for _, d := range deliveries {
	ids = append(ids, d.ID)
	statuses = append(statuses, d.Status)
}

_, err := d.db.Exec(query, pq.Array(ids), pq.Array(statuses))
return err

**
UPDATE delivery
SET status = $1
WHERE id = ANY($2::bigint[]);

ids := make([]int64, 0, len(deliveries))
for _, d := range deliveries {
	ids = append(ids, d.ID)
}

_, err := d.db.Exec(query, status, pq.Array(ids))


***
const batchSize = 500 // или 1000–5000, зависит от БД и объёма данных

var valueStrings []string
var valueArgs []interface{}

for i, item := range items {
    valueStrings = append(valueStrings, "(?, ?, ?, ?)")
    valueArgs = append(valueArgs, item.ID, item.Status, item.CreatedAt, item.Payload)

    if len(valueStrings) == batchSize || i == len(items)-1 {
        // Формируем запрос
        stmt := fmt.Sprintf(
            "INSERT INTO deliveries (id, status, created_at, payload) VALUES %s",
            strings.Join(valueStrings, ","),
        )

        _, err := db.Exec(stmt, valueArgs...)
        if err != nil {
            // обработка ошибки
        }

        // Сбрасываем для следующего батча
        valueStrings = valueStrings[:0]
        valueArgs = valueArgs[:0]
    }
}

const batchSize = 500 // 100–1000, зависит от БД и количества полей

for i := 0; i < len(deliveries); i += batchSize {
    end := i + batchSize
    if end > len(deliveries) {
        end = len(deliveries)
    }

    batch := deliveries[i:end]

    // Собираем placeholders и значения
    var valueStrings []string
    var valueArgs []interface{}

    for _, d := range batch {
        valueStrings = append(valueStrings, "(?, ?, ?)")
        valueArgs = append(valueArgs, d.ID, d.Status, d.CreatedAt)
    }

    stmt := fmt.Sprintf(
        "INSERT INTO deliveries (id, status, created_at) VALUES %s",
        strings.Join(valueStrings, ","),
    )

    _, err := db.Exec(stmt, valueArgs...)
    if err != nil {
        // обработка ошибки
    }
}
